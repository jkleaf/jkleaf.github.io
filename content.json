[{"title":"类加载器","date":"2019-07-04T08:55:51.000Z","path":"2019/07/04/类加载器/","text":"类加载器加载Class大致要经过如下8个步骤：1.检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。 2.如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。 3.请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。 4.请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。 5.当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。 6.从文件中载入Class，成功后跳至第8步。 7.抛出ClassNotFountException异常。 8.返回对应的java.lang.Class对象。 创建并使用自定义的类加载器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class CompileClassLoader extends ClassLoader &#123; // 读取一个文件的内容 private byte[] getBytes(String filename) throws IOException &#123; File file = new File(filename); long len = file.length(); byte[] raw = new byte[(int) len]; try (FileInputStream fin = new FileInputStream(file)) &#123; // 一次读取class文件的全部二进制数据 int r = fin.read(raw); if (r != len) throw new IOException(\"无法读取全部文件：\" + r + \" != \" + len); return raw; &#125; &#125; // 定义编译指定Java文件的方法 private boolean compile(String javaFile) throws IOException &#123; System.out.println(\"CompileClassLoader:正在编译 \" + javaFile + \"...\"); // 调用系统的javac命令 Process p = Runtime.getRuntime().exec(\"javac \" + javaFile); try &#123; // 其他线程都等待这个线程完成 p.waitFor(); &#125; catch (InterruptedException ie) &#123; System.out.println(ie); &#125; // 获取javac线程的退出值 int ret = p.exitValue(); // 返回编译是否成功 return ret == 0; &#125; // 重写ClassLoader的findClass方法 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = null; // 将包路径中的点（.）替换成斜线（/）。 String fileStub = name.replace(\".\", \"/\"); String javaFilename = fileStub + \".java\"; String classFilename = fileStub + \".class\"; File javaFile = new File(javaFilename); File classFile = new File(classFilename); // 当指定Java源文件存在，且class文件不存在、或者Java源文件 // 的修改时间比class文件修改时间更晚，重新编译 if (javaFile.exists() &amp;&amp; (!classFile.exists() || javaFile.lastModified() &gt; classFile.lastModified())) &#123; try &#123; // 如果编译失败，或者该Class文件不存在 if (!compile(javaFilename) || !classFile.exists()) &#123; throw new ClassNotFoundException(\"ClassNotFoundExcetpion:\" + javaFilename); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; // 如果class文件存在，系统负责将该文件转换成Class对象 if (classFile.exists()) &#123; try &#123; // 将class文件的二进制数据读入数组 byte[] raw = getBytes(classFilename); // 调用ClassLoader的defineClass方法将二进制数据转换成Class对象 clazz = defineClass(name, raw, 0, raw.length); &#125; catch (IOException ie) &#123; ie.printStackTrace(); &#125; &#125; // 如果clazz为null，表明加载失败，则抛出异常 if (clazz == null) &#123; throw new ClassNotFoundException(name); &#125; return clazz; &#125; // 定义一个主方法 public static void main(String[] args) throws Exception &#123; // 如果运行该程序时没有参数，即没有目标类 if (args.length &lt; 1) &#123; System.out.println(\"缺少目标类，请按如下格式运行Java源文件：\"); System.out.println(\"java CompileClassLoader ClassName\"); &#125; // 第一个参数是需要运行的类 String progClass = args[0]; // 剩下的参数将作为运行目标类时的参数， // 将这些参数复制到一个新数组中 String[] progArgs = new String[args.length - 1]; System.arraycopy(args, 1, progArgs, 0, progArgs.length); CompileClassLoader ccl = new CompileClassLoader(); // 加载需要运行的类(调用了重写过的findClass) Class&lt;?&gt; clazz = ccl.loadClass(progClass); // 获取需要运行的类的主方法(public static void main(String[] args)) Method main = clazz.getMethod(\"main\", (new String[0]).getClass());//new String[0] Object[] argsArray = &#123; progArgs &#125;; //源码注释:If the underlying method is static, then the specified &#123;@code obj&#125; //argument is ignored. It may be null. main.invoke(null, argsArray); &#125;&#125;/*在本类中的findClass()方法中先检查需要加载类的Class文件是否存在，如果不存在则先编译源文件，再调用ClassLoader的defineClass()方法来加载这个Class文件，并生成相应的Class对象。*/ 接下来可以随意提供一个简单的主类，该主类无须编译就可以使用上面的CompileClassLoader来运行它。 1234567public class Hello &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; System.out.println(\"运行Hello的参数:\" + arg); &#125; &#125;&#125; 直接使用如下命令: java CompileClassLoader Hello param1 运行结果如下: CompileClassLoader:正在编译 Hello.java... 运行Hello的参数:param1 使用自定义的类加载器，可以实现如下常见功能： 执行代码前自动验证数字签名。 根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译class文件。 根据用户需求来动态地加载类 根据应用需求把其他数字以字节码的形式加载到应用中 URLClassLoader类URLClassLoader功能比较强大，它既可以从本地文件系统读取二进制文件来加载类，也可以从远程主机获取二进制文件来加载类。 下面程序示范了如何直接从文件系统中加载MySQL驱动，并使用该驱动来获取数据库连接，通过这种方式来取得数据库连接就可以无须将MySQL驱动添加到CLASSPATH环境变量中。 1234567891011121314151617181920212223242526272829303132public class URLClassLoaderTest &#123; private static Connection conn; // 定义一个获取数据库连接方法 public static Connection getConn(String url, String user, String pass) throws Exception &#123; if (conn == null) &#123; // 创建一个URL数组 //file:为前缀(本地文件系统加载) //http:为前缀(从互联网通过HTTP访问来加载) URL[] urls = &#123; new URL(\"file:mysql-connector-java-8.0.12.jar\") &#125;; // 以默认的ClassLoader作为父ClassLoader，创建URLClassLoader URLClassLoader myClassLoader = new URLClassLoader(urls); // 调用该对象的loadClass()方法来加载MySQL的JDBC驱动，并创建默认实例 //通过Driver而不是DriverManager来获取数据库连接 //Class.newInstance()只能反射无参的构造器； //Constructor.newInstance()可以反射任何构造器； Driver driver = (Driver) myClassLoader.loadClass(\"com.mysql.jdbc.Driver\").getConstructor().newInstance(); // 创建一个设置JDBC连接属性的Properties对象 Properties props = new Properties(); // 至少需要为该对象传入user和password两个属性 props.setProperty(\"user\", user); props.setProperty(\"password\", pass); // 调用Driver对象的connect方法来取得数据库连接 conn = driver.connect(url, props); &#125; return conn; &#125; public static void main(String[] args) throws Exception &#123; System.out.println(getConn(\"jdbc:mysql://localhost:3306/mysql\", \"root\", \"mysql\")); &#125;&#125;","raw":"---\ntitle: 类加载器\ndate: 2019-07-04 16:55:51\ntags: 反射Reflect\ncategories: java\n---\n\n### 类加载器加载Class大致要经过如下8个步骤：\n\n1.检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。\n\n2.如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。\n\n3.请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。\n\n4.请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。\n\n5.当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。\n\n6.从文件中载入Class，成功后跳至第8步。\n\n7.抛出ClassNotFountException异常。\n\n8.返回对应的java.lang.Class对象。\n\n### 创建并使用自定义的类加载器\n\n```java\npublic class CompileClassLoader extends ClassLoader {\n\t// 读取一个文件的内容\n\tprivate byte[] getBytes(String filename) throws IOException {\n\t\tFile file = new File(filename);\n\t\tlong len = file.length();\n\t\tbyte[] raw = new byte[(int) len];\n\t\ttry (FileInputStream fin = new FileInputStream(file)) {\n\t\t\t// 一次读取class文件的全部二进制数据\n\t\t\tint r = fin.read(raw);\n\t\t\tif (r != len)\n\t\t\t\tthrow new IOException(\"无法读取全部文件：\" + r + \" != \" + len);\n\t\t\treturn raw;\n\t\t}\n\t}\n\n\t// 定义编译指定Java文件的方法\n\tprivate boolean compile(String javaFile) throws IOException {\n\t\tSystem.out.println(\"CompileClassLoader:正在编译 \" + javaFile + \"...\");\n\t\t// 调用系统的javac命令\n\t\tProcess p = Runtime.getRuntime().exec(\"javac \" + javaFile);\n\t\ttry {\n\t\t\t// 其他线程都等待这个线程完成\n\t\t\tp.waitFor();\n\t\t} catch (InterruptedException ie) {\n\t\t\tSystem.out.println(ie);\n\t\t}\n\t\t// 获取javac线程的退出值\n\t\tint ret = p.exitValue();\n\t\t// 返回编译是否成功\n\t\treturn ret == 0;\n\t}\n\n\t// 重写ClassLoader的findClass方法\n\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\tClass clazz = null;\n\t\t// 将包路径中的点（.）替换成斜线（/）。\n\t\tString fileStub = name.replace(\".\", \"/\");\n\t\tString javaFilename = fileStub + \".java\";\n\t\tString classFilename = fileStub + \".class\";\n\t\tFile javaFile = new File(javaFilename);\n\t\tFile classFile = new File(classFilename);\n\t\t// 当指定Java源文件存在，且class文件不存在、或者Java源文件\n\t\t// 的修改时间比class文件修改时间更晚，重新编译\n\t\tif (javaFile.exists() && (!classFile.exists() || javaFile.lastModified() > classFile.lastModified())) {\n\t\t\ttry {\n\t\t\t\t// 如果编译失败，或者该Class文件不存在\n\t\t\t\tif (!compile(javaFilename) || !classFile.exists()) {\n\t\t\t\t\tthrow new ClassNotFoundException(\"ClassNotFoundExcetpion:\" + javaFilename);\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t// 如果class文件存在，系统负责将该文件转换成Class对象\n\t\tif (classFile.exists()) {\n\t\t\ttry {\n\t\t\t\t// 将class文件的二进制数据读入数组\n\t\t\t\tbyte[] raw = getBytes(classFilename);\n\t\t\t\t// 调用ClassLoader的defineClass方法将二进制数据转换成Class对象\n\t\t\t\tclazz = defineClass(name, raw, 0, raw.length);\n\t\t\t} catch (IOException ie) {\n\t\t\t\tie.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t// 如果clazz为null，表明加载失败，则抛出异常\n\t\tif (clazz == null) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t\treturn clazz;\n\t}\n\n\t// 定义一个主方法\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 如果运行该程序时没有参数，即没有目标类\n\t\tif (args.length < 1) {\n\t\t\tSystem.out.println(\"缺少目标类，请按如下格式运行Java源文件：\");\n\t\t\tSystem.out.println(\"java CompileClassLoader ClassName\");\n\t\t}\n\t\t// 第一个参数是需要运行的类\n\t\tString progClass = args[0];\n\t\t// 剩下的参数将作为运行目标类时的参数，\n\t\t// 将这些参数复制到一个新数组中\n\t\tString[] progArgs = new String[args.length - 1];\n\t\tSystem.arraycopy(args, 1, progArgs, 0, progArgs.length);\n\t\tCompileClassLoader ccl = new CompileClassLoader();\n\t\t// 加载需要运行的类(调用了重写过的findClass)\n\t\tClass<?> clazz = ccl.loadClass(progClass);\n\t\t// 获取需要运行的类的主方法(public static void main(String[] args))\n\t\tMethod main = clazz.getMethod(\"main\", (new String[0]).getClass());//new String[0]\n\t\tObject[] argsArray = { progArgs };\n        //源码注释:If the underlying method is static, then the specified {@code obj}\n      \t//argument is ignored. It may be null.\n\t\tmain.invoke(null, argsArray);\n\t}\n}\n/*在本类中的findClass()方法中先检查需要加载类的Class文件是否存在，如果不存在则先编译源文件，再调用ClassLoader的defineClass()方法来加载这个Class文件，并生成相应的Class对象。*/\n```\n\n接下来可以随意提供一个简单的主类，该主类无须编译就可以使用上面的CompileClassLoader来运行它。\n\n```java\npublic class Hello {\n\tpublic static void main(String[] args) {\n\t\tfor (String arg : args) {\n\t\t\tSystem.out.println(\"运行Hello的参数:\" + arg);\n\t\t}\n\t}\n}\n```\n\n直接使用如下命令:\n\n`java CompileClassLoader Hello param1`\n\n运行结果如下:\n\n`CompileClassLoader:正在编译 Hello.java...`\n\n`运行Hello的参数:param1`\n\n**使用自定义的类加载器，可以实现如下常见功能：**\n\n- 执行代码前自动验证数字签名。\n- 根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译class文件。\n- 根据用户需求来动态地加载类\n- 根据应用需求把其他数字以字节码的形式加载到应用中\n\n### URLClassLoader类\n\nURLClassLoader功能比较强大，它既可以从本地文件系统读取二进制文件来加载类，也可以从远程主机获取二进制文件来加载类。\n\n下面程序示范了如何直接从文件系统中加载MySQL驱动，并使用该驱动来获取数据库连接，通过这种方式来取得数据库连接就可以无须将MySQL驱动添加到CLASSPATH环境变量中。\n\n```java\npublic class URLClassLoaderTest {\n\tprivate static Connection conn;\n\n\t// 定义一个获取数据库连接方法\n\tpublic static Connection getConn(String url, String user, String pass) throws Exception {\n\t\tif (conn == null) {\n\t\t\t// 创建一个URL数组\n            //file:为前缀(本地文件系统加载)\n            //http:为前缀(从互联网通过HTTP访问来加载)\n\t\t\tURL[] urls = { new URL(\"file:mysql-connector-java-8.0.12.jar\") };\n\t\t\t// 以默认的ClassLoader作为父ClassLoader，创建URLClassLoader\n\t\t\tURLClassLoader myClassLoader = new URLClassLoader(urls);\n\t\t\t// 调用该对象的loadClass()方法来加载MySQL的JDBC驱动，并创建默认实例\n            //通过Driver而不是DriverManager来获取数据库连接\n            //Class.newInstance()只能反射无参的构造器；\n\t\t\t//Constructor.newInstance()可以反射任何构造器；\n\t\t\tDriver driver = (Driver) myClassLoader.loadClass(\"com.mysql.jdbc.Driver\").getConstructor().newInstance();\n\t\t\t// 创建一个设置JDBC连接属性的Properties对象\n\t\t\tProperties props = new Properties();\n\t\t\t// 至少需要为该对象传入user和password两个属性\n\t\t\tprops.setProperty(\"user\", user);\n\t\t\tprops.setProperty(\"password\", pass);\n\t\t\t// 调用Driver对象的connect方法来取得数据库连接\n\t\t\tconn = driver.connect(url, props);\n\t\t}\n\t\treturn conn;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.println(getConn(\"jdbc:mysql://localhost:3306/mysql\", \"root\", \"mysql\"));\n\t}\n}\n```","slug":"类加载器","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"反射Reflect","slug":"反射Reflect","permalink":"http://yoursite.com/tags/反射Reflect/"}]},{"title":"林景煌SB","date":"2019-03-08T09:18:59.000Z","path":"2019/03/08/林景煌SB/","text":"林—_— 景—_— 煌","raw":"---\ntitle: 林景煌SB\ndate: 2019-03-08 17:18:59\ntags: Really?\ncategories: Test\n---\n\n## 林\n\n—_—\n\n---\n\n## 景\n\n—_—\n\n---\n\n## 煌\n\n![Dark](/img/dark.jpg)\n\n---\n","slug":"林景煌SB","excerpt":"","categories":[{"name":"Test","slug":"Test","permalink":"http://yoursite.com/categories/Test/"}],"tags":[{"name":"Really?","slug":"Really","permalink":"http://yoursite.com/tags/Really/"}]},{"title":"Hello World","date":"2019-03-08T07:18:58.825Z","path":"2019/03/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","excerpt":"","categories":[],"tags":[]}]
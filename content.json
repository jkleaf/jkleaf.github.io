[{"title":"Redis安装与配置","date":"2019-07-18T15:55:45.000Z","path":"2019/07/18/Redis安装与配置/","text":"Redis下载 ​ Redis官网 Centos7安装Redis 执行以下命令下载Redis： wget http://download.redis.io/releases/版本号.tar.gz 解压Redis： tar -zxvf redis-版本号.tar.gz cd进入解压目录执行编译和安装命令 编译命令： make MALLOC=linbc 编译过程… 编译结束，执行安装命令： make install 安装结束ヽ(ー_ー)ノ 配置Redis 修改redis.conf文件","raw":"---\ntitle: Redis安装与配置\ndate: 2019-07-18 23:55:45\ntags: Redis安装与配置\ncategories: NoSQL\n---\n\n- **Redis下载**\n\n  ​\t[Redis官网](https://redis.io/)\n\n  ![Redis latest stable version](/img/redis/download_Redis.png)\n\n- **Centos7安装Redis**\n\n  执行以下命令下载Redis：\n\n  ``wget http://download.redis.io/releases/版本号.tar.gz``\n\n  ![wget Redis](/img/redis/wget_Redis.png)\n\n  解压Redis：\n\n  ``tar -zxvf redis-版本号.tar.gz ``\n\n  `cd`进入解压目录执行编译和安装命令\n\n  编译命令：\n\n  `make MALLOC=linbc`\n\n  编译过程...\n\n  ![make MALLOC=linbc](/img/redis/compile_Redis_1.png)\n\n  ![complete](/img/redis/compile_Redis_2.png)\n\n  编译结束，执行安装命令：\n\n  `make install`\n\n  ![make install](/img/redis/install_Redis.png)\n  \n  安装结束ヽ(ー_ー)ノ\n\n- **配置Redis**\n\n  修改redis.conf文件\n\n  \n","slug":"Redis安装与配置","excerpt":"","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://yoursite.com/categories/NoSQL/"}],"tags":[{"name":"Redis安装与配置","slug":"Redis安装与配置","permalink":"http://yoursite.com/tags/Redis安装与配置/"}]},{"title":"动态代理和AOP","date":"2019-07-05T13:11:47.000Z","path":"2019/07/05/动态代理和AOP/","text":"由于JDK动态代理只能为接口创建动态代理，所以以下提供一个Dog接口： 123456public interface Dog &#123; void info(); void run();&#125; 及其实现类GunDog： 123456789101112public class GunDog implements Dog &#123; @Override public void info() &#123; System.out.println(\"猎狗\"); &#125; @Override public void run() &#123; System.out.println(\"奔跑\"); &#125;&#125; 要求：程序在执行info()、run()方法时能调用某些通用方法，但又不想以硬编码方式调用该方法。下面提供一个DogUtil类，该类里包含两个通用方法： 12345678910public class DogUtil &#123; public void method1() &#123; System.out.println(\"通用方法一\"); &#125; public void method2() &#123; System.out.println(\"通用方法二\"); &#125;&#125; 借助于Proxy和InvocationHandler就可以实现——当程序调用info()和run()方法时，系统可以“自动”将两个通用方法插入info()和run()方法中执行。这个程序的关键在于下面的MyInvokationHandler类。作为InvocationHandler的实现类，该类的invoke()方法将会作为代理对象的方法实现： 12345678910111213141516171819202122public class MyInvokationHandler implements InvocationHandler &#123; // 需要代理的对象 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; // 执行动态代理的所有方法时，都会被替换成执行如下的invoke方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; DogUtil du = new DogUtil(); // 执行method1方法 du.method1(); // 以target作为主调来执行method方法(回调了target对象的原有方法) Object res = method.invoke(target, args); // 执行method2方法 du.method2(); return res; &#125;&#125; 下面为程序提供一个MyProxyFactory类，该对象专为指定的target生成动态代理实例： 123456789101112public class MyProxyFactory &#123; // 为指定的target生成动态对象 public static Object getProxy(Object target) throws Exception &#123; // 创建一个MyInvokationHandler对象 MyInvokationHandler handler = new MyInvokationHandler(); // 为该对象设置target对象 handler.setTarget(target); // 创建并返回一个动态代理 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); &#125;&#125; 主程序测试动态代理： 12345678910public class Test &#123; public static void main(String[] args) throws Exception &#123; // 创建一个GunDog对象作为target Dog target = new GunDog(); Dog dog = (Dog) MyProxyFactory.getProxy(target); dog.info(); dog.run(); &#125;&#125; 输出结果： 123456通用方法一猎狗通用方法二通用方法一奔跑通用方法二","raw":"---\ntitle: 动态代理和AOP\ndate: 2019-07-05 21:11:47\ntags: 反射reflect\ncategories: java\n---\n\n由于**JDK动态代理只能为接口创建动态代理**，所以以下提供一个Dog接口：\n\n```java\npublic interface Dog {\n\n\tvoid info();\n\n\tvoid run();\n}\n```\n\n及其实现类GunDog：\n\n```java\npublic class GunDog implements Dog {\n\n\t@Override\n\tpublic void info() {\n\t\tSystem.out.println(\"猎狗\");\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"奔跑\");\n\t}\n}\n```\n\n要求：程序在执行info()、run()方法时能调用某些通用方法，但又不想以硬编码方式调用该方法。下面提供一个DogUtil类，该类里包含两个通用方法：\n\n```java\npublic class DogUtil {\n\n\tpublic void method1() {\n\t\tSystem.out.println(\"通用方法一\");\n\t}\n\n\tpublic void method2() {\n\t\tSystem.out.println(\"通用方法二\");\n\t}\n}\n```\n\n借助于Proxy和InvocationHandler就可以实现——当程序调用info()和run()方法时，系统可以“自动”将两个通用方法**插入**info()和run()方法中执行。这个程序的关键在于下面的MyInvokationHandler类。作为InvocationHandler的实现类，该类的invoke()方法将会作为代理对象的方法实现：\n\n```java\npublic class MyInvokationHandler implements InvocationHandler {\n\n\t// 需要代理的对象\n\tprivate Object target;\n\n\tpublic void setTarget(Object target) {\n\t\tthis.target = target;\n\t}\n\n\t// 执行动态代理的所有方法时，都会被替换成执行如下的invoke方法\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tDogUtil du = new DogUtil();\n\t\t// 执行method1方法\n\t\tdu.method1();\n\t\t// 以target作为主调来执行method方法(回调了target对象的原有方法)\n\t\tObject res = method.invoke(target, args);\n\t\t// 执行method2方法\n\t\tdu.method2();\n    \treturn res;\n\t}\n}\n```\n\n下面为程序提供一个MyProxyFactory类，该对象专为指定的target生成动态代理实例：\n\n```java\npublic class MyProxyFactory {\n\n\t// 为指定的target生成动态对象\n\tpublic static Object getProxy(Object target) throws Exception {\n\t\t// 创建一个MyInvokationHandler对象\n\t\tMyInvokationHandler handler = new MyInvokationHandler();\n\t\t// 为该对象设置target对象\n\t\thandler.setTarget(target);\n\t\t// 创建并返回一个动态代理\n\t\treturn Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);\n\t}\n}\n```\n\n主程序测试动态代理：\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 创建一个GunDog对象作为target\n\t\tDog target = new GunDog();\n\t\tDog dog = (Dog) MyProxyFactory.getProxy(target);\n\t\tdog.info();\n\t\tdog.run();\n\t}\n}\n```\n\n输出结果：\n\n```\n通用方法一\n猎狗\n通用方法二\n通用方法一\n奔跑\n通用方法二\n```\n\n\n![AOP代理的方法与目标对象的方法示意图](/img/aop.png)","slug":"动态代理和AOP","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"反射reflect","slug":"反射reflect","permalink":"http://yoursite.com/tags/反射reflect/"}]},{"title":"类加载器","date":"2019-07-04T08:55:51.000Z","path":"2019/07/04/类加载器/","text":"类加载器加载Class大致要经过如下8个步骤：1.检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。 2.如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。 3.请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。 4.请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。 5.当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。 6.从文件中载入Class，成功后跳至第8步。 7.抛出ClassNotFountException异常。 8.返回对应的java.lang.Class对象。 创建并使用自定义的类加载器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class CompileClassLoader extends ClassLoader &#123; // 读取一个文件的内容 private byte[] getBytes(String filename) throws IOException &#123; File file = new File(filename); long len = file.length(); byte[] raw = new byte[(int) len]; try (FileInputStream fin = new FileInputStream(file)) &#123; // 一次读取class文件的全部二进制数据 int r = fin.read(raw); if (r != len) throw new IOException(\"无法读取全部文件：\" + r + \" != \" + len); return raw; &#125; &#125; // 定义编译指定Java文件的方法 private boolean compile(String javaFile) throws IOException &#123; System.out.println(\"CompileClassLoader:正在编译 \" + javaFile + \"...\"); // 调用系统的javac命令 Process p = Runtime.getRuntime().exec(\"javac \" + javaFile); try &#123; // 其他线程都等待这个线程完成 p.waitFor(); &#125; catch (InterruptedException ie) &#123; System.out.println(ie); &#125; // 获取javac线程的退出值 int ret = p.exitValue(); // 返回编译是否成功 return ret == 0; &#125; // 重写ClassLoader的findClass方法 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = null; // 将包路径中的点（.）替换成斜线（/）。 String fileStub = name.replace(\".\", \"/\"); String javaFilename = fileStub + \".java\"; String classFilename = fileStub + \".class\"; File javaFile = new File(javaFilename); File classFile = new File(classFilename); // 当指定Java源文件存在，且class文件不存在、或者Java源文件 // 的修改时间比class文件修改时间更晚，重新编译 if (javaFile.exists() &amp;&amp; (!classFile.exists() || javaFile.lastModified() &gt; classFile.lastModified())) &#123; try &#123; // 如果编译失败，或者该Class文件不存在 if (!compile(javaFilename) || !classFile.exists()) &#123; throw new ClassNotFoundException(\"ClassNotFoundExcetpion:\" + javaFilename); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; // 如果class文件存在，系统负责将该文件转换成Class对象 if (classFile.exists()) &#123; try &#123; // 将class文件的二进制数据读入数组 byte[] raw = getBytes(classFilename); // 调用ClassLoader的defineClass方法将二进制数据转换成Class对象 clazz = defineClass(name, raw, 0, raw.length); &#125; catch (IOException ie) &#123; ie.printStackTrace(); &#125; &#125; // 如果clazz为null，表明加载失败，则抛出异常 if (clazz == null) &#123; throw new ClassNotFoundException(name); &#125; return clazz; &#125; // 定义一个主方法 public static void main(String[] args) throws Exception &#123; // 如果运行该程序时没有参数，即没有目标类 if (args.length &lt; 1) &#123; System.out.println(\"缺少目标类，请按如下格式运行Java源文件：\"); System.out.println(\"java CompileClassLoader ClassName\"); &#125; // 第一个参数是需要运行的类 String progClass = args[0]; // 剩下的参数将作为运行目标类时的参数， // 将这些参数复制到一个新数组中 String[] progArgs = new String[args.length - 1]; System.arraycopy(args, 1, progArgs, 0, progArgs.length); CompileClassLoader ccl = new CompileClassLoader(); // 加载需要运行的类(调用了重写过的findClass) Class&lt;?&gt; clazz = ccl.loadClass(progClass); // 获取需要运行的类的主方法(public static void main(String[] args)) Method main = clazz.getMethod(\"main\", (new String[0]).getClass());//new String[0] Object[] argsArray = &#123; progArgs &#125;; //源码注释:If the underlying method is static, then the specified &#123;@code obj&#125; //argument is ignored. It may be null. main.invoke(null, argsArray); &#125;&#125;/*在本类中的findClass()方法中先检查需要加载类的Class文件是否存在，如果不存在则先编译源文件，再调用ClassLoader的defineClass()方法来加载这个Class文件，并生成相应的Class对象。*/ 接下来可以随意提供一个简单的主类，该主类无须编译就可以使用上面的CompileClassLoader来运行它。 1234567public class Hello &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; System.out.println(\"运行Hello的参数:\" + arg); &#125; &#125;&#125; 直接使用如下命令: java CompileClassLoader Hello param1 运行结果如下: CompileClassLoader:正在编译 Hello.java... 运行Hello的参数:param1 使用自定义的类加载器，可以实现如下常见功能： 执行代码前自动验证数字签名。 根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译class文件。 根据用户需求来动态地加载类 根据应用需求把其他数字以字节码的形式加载到应用中 URLClassLoader类URLClassLoader功能比较强大，它既可以从本地文件系统读取二进制文件来加载类，也可以从远程主机获取二进制文件来加载类。 下面程序示范了如何直接从文件系统中加载MySQL驱动，并使用该驱动来获取数据库连接，通过这种方式来取得数据库连接就可以无须将MySQL驱动添加到CLASSPATH环境变量中。 1234567891011121314151617181920212223242526272829303132public class URLClassLoaderTest &#123; private static Connection conn; // 定义一个获取数据库连接方法 public static Connection getConn(String url, String user, String pass) throws Exception &#123; if (conn == null) &#123; // 创建一个URL数组 //file:为前缀(本地文件系统加载) //http:为前缀(从互联网通过HTTP访问来加载) URL[] urls = &#123; new URL(\"file:mysql-connector-java-8.0.12.jar\") &#125;; // 以默认的ClassLoader作为父ClassLoader，创建URLClassLoader URLClassLoader myClassLoader = new URLClassLoader(urls); // 调用该对象的loadClass()方法来加载MySQL的JDBC驱动，并创建默认实例 //通过Driver而不是DriverManager来获取数据库连接 //Class.newInstance()只能反射无参的构造器； //Constructor.newInstance()可以反射任何构造器； Driver driver = (Driver) myClassLoader.loadClass(\"com.mysql.jdbc.Driver\").getConstructor().newInstance(); // 创建一个设置JDBC连接属性的Properties对象 Properties props = new Properties(); // 至少需要为该对象传入user和password两个属性 props.setProperty(\"user\", user); props.setProperty(\"password\", pass); // 调用Driver对象的connect方法来取得数据库连接 conn = driver.connect(url, props); &#125; return conn; &#125; public static void main(String[] args) throws Exception &#123; System.out.println(getConn(\"jdbc:mysql://localhost:3306/mysql\", \"root\", \"mysql\")); &#125;&#125;","raw":"---\ntitle: 类加载器\ndate: 2019-07-04 16:55:51\ntags: 反射Reflect\ncategories: java\n---\n\n### 类加载器加载Class大致要经过如下8个步骤：\n\n1.检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。\n\n2.如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。\n\n3.请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。\n\n4.请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。\n\n5.当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。\n\n6.从文件中载入Class，成功后跳至第8步。\n\n7.抛出ClassNotFountException异常。\n\n8.返回对应的java.lang.Class对象。\n\n### 创建并使用自定义的类加载器\n\n```java\npublic class CompileClassLoader extends ClassLoader {\n\t// 读取一个文件的内容\n\tprivate byte[] getBytes(String filename) throws IOException {\n\t\tFile file = new File(filename);\n\t\tlong len = file.length();\n\t\tbyte[] raw = new byte[(int) len];\n\t\ttry (FileInputStream fin = new FileInputStream(file)) {\n\t\t\t// 一次读取class文件的全部二进制数据\n\t\t\tint r = fin.read(raw);\n\t\t\tif (r != len)\n\t\t\t\tthrow new IOException(\"无法读取全部文件：\" + r + \" != \" + len);\n\t\t\treturn raw;\n\t\t}\n\t}\n\n\t// 定义编译指定Java文件的方法\n\tprivate boolean compile(String javaFile) throws IOException {\n\t\tSystem.out.println(\"CompileClassLoader:正在编译 \" + javaFile + \"...\");\n\t\t// 调用系统的javac命令\n\t\tProcess p = Runtime.getRuntime().exec(\"javac \" + javaFile);\n\t\ttry {\n\t\t\t// 其他线程都等待这个线程完成\n\t\t\tp.waitFor();\n\t\t} catch (InterruptedException ie) {\n\t\t\tSystem.out.println(ie);\n\t\t}\n\t\t// 获取javac线程的退出值\n\t\tint ret = p.exitValue();\n\t\t// 返回编译是否成功\n\t\treturn ret == 0;\n\t}\n\n\t// 重写ClassLoader的findClass方法\n\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\tClass clazz = null;\n\t\t// 将包路径中的点（.）替换成斜线（/）。\n\t\tString fileStub = name.replace(\".\", \"/\");\n\t\tString javaFilename = fileStub + \".java\";\n\t\tString classFilename = fileStub + \".class\";\n\t\tFile javaFile = new File(javaFilename);\n\t\tFile classFile = new File(classFilename);\n\t\t// 当指定Java源文件存在，且class文件不存在、或者Java源文件\n\t\t// 的修改时间比class文件修改时间更晚，重新编译\n\t\tif (javaFile.exists() && (!classFile.exists() || javaFile.lastModified() > classFile.lastModified())) {\n\t\t\ttry {\n\t\t\t\t// 如果编译失败，或者该Class文件不存在\n\t\t\t\tif (!compile(javaFilename) || !classFile.exists()) {\n\t\t\t\t\tthrow new ClassNotFoundException(\"ClassNotFoundExcetpion:\" + javaFilename);\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t// 如果class文件存在，系统负责将该文件转换成Class对象\n\t\tif (classFile.exists()) {\n\t\t\ttry {\n\t\t\t\t// 将class文件的二进制数据读入数组\n\t\t\t\tbyte[] raw = getBytes(classFilename);\n\t\t\t\t// 调用ClassLoader的defineClass方法将二进制数据转换成Class对象\n\t\t\t\tclazz = defineClass(name, raw, 0, raw.length);\n\t\t\t} catch (IOException ie) {\n\t\t\t\tie.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t// 如果clazz为null，表明加载失败，则抛出异常\n\t\tif (clazz == null) {\n\t\t\tthrow new ClassNotFoundException(name);\n\t\t}\n\t\treturn clazz;\n\t}\n\n\t// 定义一个主方法\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 如果运行该程序时没有参数，即没有目标类\n\t\tif (args.length < 1) {\n\t\t\tSystem.out.println(\"缺少目标类，请按如下格式运行Java源文件：\");\n\t\t\tSystem.out.println(\"java CompileClassLoader ClassName\");\n\t\t}\n\t\t// 第一个参数是需要运行的类\n\t\tString progClass = args[0];\n\t\t// 剩下的参数将作为运行目标类时的参数，\n\t\t// 将这些参数复制到一个新数组中\n\t\tString[] progArgs = new String[args.length - 1];\n\t\tSystem.arraycopy(args, 1, progArgs, 0, progArgs.length);\n\t\tCompileClassLoader ccl = new CompileClassLoader();\n\t\t// 加载需要运行的类(调用了重写过的findClass)\n\t\tClass<?> clazz = ccl.loadClass(progClass);\n\t\t// 获取需要运行的类的主方法(public static void main(String[] args))\n\t\tMethod main = clazz.getMethod(\"main\", (new String[0]).getClass());//new String[0]\n\t\tObject[] argsArray = { progArgs };\n        //源码注释:If the underlying method is static, then the specified {@code obj}\n      \t//argument is ignored. It may be null.\n\t\tmain.invoke(null, argsArray);\n\t}\n}\n/*在本类中的findClass()方法中先检查需要加载类的Class文件是否存在，如果不存在则先编译源文件，再调用ClassLoader的defineClass()方法来加载这个Class文件，并生成相应的Class对象。*/\n```\n\n接下来可以随意提供一个简单的主类，该主类无须编译就可以使用上面的CompileClassLoader来运行它。\n\n```java\npublic class Hello {\n\tpublic static void main(String[] args) {\n\t\tfor (String arg : args) {\n\t\t\tSystem.out.println(\"运行Hello的参数:\" + arg);\n\t\t}\n\t}\n}\n```\n\n直接使用如下命令:\n\n`java CompileClassLoader Hello param1`\n\n运行结果如下:\n\n`CompileClassLoader:正在编译 Hello.java...`\n\n`运行Hello的参数:param1`\n\n**使用自定义的类加载器，可以实现如下常见功能：**\n\n- 执行代码前自动验证数字签名。\n- 根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译class文件。\n- 根据用户需求来动态地加载类\n- 根据应用需求把其他数字以字节码的形式加载到应用中\n\n### URLClassLoader类\n\nURLClassLoader功能比较强大，它既可以从本地文件系统读取二进制文件来加载类，也可以从远程主机获取二进制文件来加载类。\n\n下面程序示范了如何直接从文件系统中加载MySQL驱动，并使用该驱动来获取数据库连接，通过这种方式来取得数据库连接就可以无须将MySQL驱动添加到CLASSPATH环境变量中。\n\n```java\npublic class URLClassLoaderTest {\n\tprivate static Connection conn;\n\n\t// 定义一个获取数据库连接方法\n\tpublic static Connection getConn(String url, String user, String pass) throws Exception {\n\t\tif (conn == null) {\n\t\t\t// 创建一个URL数组\n            //file:为前缀(本地文件系统加载)\n            //http:为前缀(从互联网通过HTTP访问来加载)\n\t\t\tURL[] urls = { new URL(\"file:mysql-connector-java-8.0.12.jar\") };\n\t\t\t// 以默认的ClassLoader作为父ClassLoader，创建URLClassLoader\n\t\t\tURLClassLoader myClassLoader = new URLClassLoader(urls);\n\t\t\t// 调用该对象的loadClass()方法来加载MySQL的JDBC驱动，并创建默认实例\n            //通过Driver而不是DriverManager来获取数据库连接\n            //Class.newInstance()只能反射无参的构造器；\n\t\t\t//Constructor.newInstance()可以反射任何构造器；\n\t\t\tDriver driver = (Driver) myClassLoader.loadClass(\"com.mysql.jdbc.Driver\").getConstructor().newInstance();\n\t\t\t// 创建一个设置JDBC连接属性的Properties对象\n\t\t\tProperties props = new Properties();\n\t\t\t// 至少需要为该对象传入user和password两个属性\n\t\t\tprops.setProperty(\"user\", user);\n\t\t\tprops.setProperty(\"password\", pass);\n\t\t\t// 调用Driver对象的connect方法来取得数据库连接\n\t\t\tconn = driver.connect(url, props);\n\t\t}\n\t\treturn conn;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSystem.out.println(getConn(\"jdbc:mysql://localhost:3306/mysql\", \"root\", \"mysql\"));\n\t}\n}\n```","slug":"类加载器","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"反射Reflect","slug":"反射Reflect","permalink":"http://yoursite.com/tags/反射Reflect/"}]},{"title":"林景煌SB","date":"2019-03-08T09:18:59.000Z","path":"2019/03/08/林景煌SB/","text":"林—_— 景—_— 煌","raw":"---\ntitle: 林景煌SB\ndate: 2019-03-08 17:18:59\ntags: Really?\ncategories: Test\n---\n\n## 林\n\n—_—\n\n---\n\n## 景\n\n—_—\n\n---\n\n## 煌\n\n![Dark](/img/dark.jpg)\n\n---\n","slug":"林景煌SB","excerpt":"","categories":[{"name":"Test","slug":"Test","permalink":"http://yoursite.com/categories/Test/"}],"tags":[{"name":"Really?","slug":"Really","permalink":"http://yoursite.com/tags/Really/"}]},{"title":"Hello World","date":"2019-03-08T07:18:58.825Z","path":"2019/03/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","excerpt":"","categories":[],"tags":[]}]